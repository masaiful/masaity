{"version":3,"names":[],"mappings":"","sources":["packages/workbox-google-analytics/browser.mjs"],"sourcesContent":["this.workbox = this.workbox || {};\nthis.workbox.googleAnalytics = (function (exports,Plugin_mjs,cacheNames_mjs,getFriendlyURL_mjs,logger_mjs,Route_mjs,Router_mjs,NetworkFirst_mjs,NetworkOnly_mjs) {\n  'use strict';\n\n  try {\n    self.workbox.v['workbox:google-analytics:4.0.0-beta.0'] = 1;\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  const QUEUE_NAME = 'workbox-google-analytics';\n  const MAX_RETENTION_TIME = 60 * 48; // Two days in minutes\n\n  const GOOGLE_ANALYTICS_HOST = 'www.google-analytics.com';\n  const GTM_HOST = 'www.googletagmanager.com';\n  const ANALYTICS_JS_PATH = '/analytics.js';\n  const GTAG_JS_PATH = '/gtag/js';\n  // endpoints. Most of the time the default path (/collect) is used, but\n  // occasionally an experimental endpoint is used when testing new features,\n  // (e.g. /r/collect or /j/collect)\n\n  const COLLECT_PATHS_REGEX = /^\\/(\\w+\\/)?collect/;\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * Creates the requestWillDequeue callback to be used with the background\n   * sync queue plugin. The callback takes the failed request and adds the\n   * `qt` param based on the current time, as well as applies any other\n   * user-defined hit modifications.\n   *\n   * @param {Object} config See workbox.googleAnalytics.initialize.\n   * @return {Function} The requestWillDequeu callback function.\n   *\n   * @private\n   */\n\n  const createOnSyncCallback = config => {\n    return async ({\n      queue\n    }) => {\n      let entry;\n\n      while (entry = await queue.shiftRequest()) {\n        const {\n          request,\n          timestamp\n        } = entry;\n        const url = new URL(request.url);\n\n        try {\n          // Measurement protocol requests can set their payload parameters in\n          // either the URL query string (for GET requests) or the POST body.\n          const params = request.method === 'POST' ? new URLSearchParams((await request.text())) : url.searchParams; // Calculate the qt param, accounting for the fact that an existing\n          // qt param may be present and should be updated rather than replaced.\n\n          const originalHitTime = timestamp - (Number(params.get('qt')) || 0);\n          const queueTime = Date.now() - originalHitTime; // Set the qt param prior to applying hitFilter or parameterOverrides.\n\n          params.set('qt', queueTime); // Apply `paramterOverrideds`, if set.\n\n          if (config.parameterOverrides) {\n            for (const param of Object.keys(config.parameterOverrides)) {\n              const value = config.parameterOverrides[param];\n              params.set(param, value);\n            }\n          } // Apply `hitFilter`, if set.\n\n\n          if (typeof config.hitFilter === 'function') {\n            config.hitFilter.call(null, params);\n          } // Retry the fetch. Ignore URL search params form the URL as they're\n          // now in the post body.\n\n\n          await fetch(new Request(url.origin + url.pathname, {\n            body: params.toString(),\n            method: 'POST',\n            mode: 'cors',\n            credentials: 'omit',\n            headers: {\n              'Content-Type': 'text/plain'\n            }\n          }));\n\n          {\n            logger_mjs.logger.log(`Request for '${getFriendlyURL_mjs.getFriendlyURL(url.href)}'` + `has been replayed`);\n          }\n        } catch (err) {\n          await queue.unshiftRequest(entry);\n\n          {\n            logger_mjs.logger.log(`Request for '${getFriendlyURL_mjs.getFriendlyURL(url.href)}'` + `failed to replay, putting it back in the queue.`);\n          }\n\n          return;\n        }\n      }\n\n      {\n        logger_mjs.logger.log(`All Google Analytics request successfully replayed; ` + `the queue is now empty!`);\n      }\n    };\n  };\n  /**\n   * Creates GET and POST routes to catch failed Measurement Protocol hits.\n   *\n   * @param {Plugin} queuePlugin\n   * @return {Array<Route>} The created routes.\n   *\n   * @private\n   */\n\n\n  const createCollectRoutes = queuePlugin => {\n    const match = ({\n      url\n    }) => url.hostname === GOOGLE_ANALYTICS_HOST && COLLECT_PATHS_REGEX.test(url.pathname);\n\n    const handler = new NetworkOnly_mjs.NetworkOnly({\n      plugins: [queuePlugin]\n    });\n    return [new Route_mjs.Route(match, handler, 'GET'), new Route_mjs.Route(match, handler, 'POST')];\n  };\n  /**\n   * Creates a route with a network first strategy for the analytics.js script.\n   *\n   * @param {string} cacheName\n   * @return {Route} The created route.\n   *\n   * @private\n   */\n\n\n  const createAnalyticsJsRoute = cacheName => {\n    const match = ({\n      url\n    }) => url.hostname === GOOGLE_ANALYTICS_HOST && url.pathname === ANALYTICS_JS_PATH;\n\n    const handler = new NetworkFirst_mjs.NetworkFirst({\n      cacheName\n    });\n    return new Route_mjs.Route(match, handler, 'GET');\n  };\n  /**\n   * Creates a route with a network first strategy for the gtag.js script.\n   *\n   * @param {string} cacheName\n   * @return {Route} The created route.\n   *\n   * @private\n   */\n\n\n  const createGtagJsRoute = cacheName => {\n    const match = ({\n      url\n    }) => url.hostname === GTM_HOST && url.pathname === GTAG_JS_PATH;\n\n    const handler = new NetworkFirst_mjs.NetworkFirst({\n      cacheName\n    });\n    return new Route_mjs.Route(match, handler, 'GET');\n  };\n  /**\n   * @param {Object=} [options]\n   * @param {Object} [options.cacheName] The cache name to store and retrieve\n   *     analytics.js. Defaults to the cache names provided by `workbox-core`.\n   * @param {Object} [options.parameterOverrides]\n   *     [Measurement Protocol parameters](https://developers.google.com/analytics/devguides/collection/protocol/v1/parameters),\n   *     expressed as key/value pairs, to be added to replayed Google Analytics\n   *     requests. This can be used to, e.g., set a custom dimension indicating\n   *     that the request was replayed.\n   * @param {Function} [options.hitFilter] A function that allows you to modify\n   *     the hit parameters prior to replaying\n   *     the hit. The function is invoked with the original hit's URLSearchParams\n   *     object as its only argument.\n   *\n   * @memberof workbox.googleAnalytics\n   */\n\n\n  const initialize = (options = {}) => {\n    const cacheName = cacheNames_mjs.cacheNames.getGoogleAnalyticsName(options.cacheName);\n    const queuePlugin = new Plugin_mjs.Plugin(QUEUE_NAME, {\n      maxRetentionTime: MAX_RETENTION_TIME,\n      onSync: createOnSyncCallback(options)\n    });\n    const routes = [createAnalyticsJsRoute(cacheName), createGtagJsRoute(cacheName), ...createCollectRoutes(queuePlugin)];\n    const router = new Router_mjs.Router();\n\n    for (const route of routes) {\n      router.registerRoute(route);\n    }\n\n    router.addFetchListener();\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  exports.initialize = initialize;\n\n  return exports;\n\n}({},workbox.backgroundSync,workbox.core._private,workbox.core._private,workbox.core._private,workbox.routing,workbox.routing,workbox.strategies,workbox.strategies));\n"],"file":"workbox-offline-ga.dev.js"}