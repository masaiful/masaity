{"version":3,"names":[],"mappings":"","sources":["packages/workbox-background-sync/browser.mjs"],"sourcesContent":["this.workbox = this.workbox || {};\nthis.workbox.backgroundSync = (function (assert_mjs,DBWrapper_mjs,migrateDb_mjs,WorkboxError_mjs,logger_mjs,getFriendlyURL_mjs) {\n  'use strict';\n\n  try {\n    self.workbox.v['workbox:background-sync:4.0.0-beta.0'] = 1;\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  const DB_VERSION = 2;\n  const DB_NAME = 'workbox-background-sync';\n  const OBJECT_STORE_NAME = 'requests';\n  const INDEXED_PROP = 'queueName';\n  const TAG_PREFIX = 'workbox-background-sync';\n  const MAX_RETENTION_TIME = 60 * 24 * 7; // 7 days in minutes\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * A class to manage storing requests from a Queue in IndexedbDB,\n   * indexed by their queue name for easier access.\n   *\n   * @private\n   */\n\n  class QueueStore {\n    /**\n     * Associates this instance with a Queue instance, so entries added can be\n     * identified by their queue name.\n     *\n     * @param {string} queueName\n     * @private\n     */\n    constructor(queueName) {\n      this._queueName = queueName;\n      this._db = new DBWrapper_mjs.DBWrapper(DB_NAME, DB_VERSION, {\n        onupgradeneeded: evt => this._upgradeDb(evt)\n      });\n    }\n    /**\n     * Append an entry last in the queue.\n     *\n     * @param {Object} entry\n     * @param {Object} entry.requestData\n     * @param {number} [entry.timestamp]\n     * @param {Object} [entry.metadata]\n     */\n\n\n    async pushEntry(entry) {\n      {\n        assert_mjs.assert.isType(entry, 'object', {\n          moduleName: 'workbox-background-sync',\n          className: 'QueueStore',\n          funcName: 'pushEntry',\n          paramName: 'entry'\n        });\n        assert_mjs.assert.isType(entry.requestData, 'object', {\n          moduleName: 'workbox-background-sync',\n          className: 'QueueStore',\n          funcName: 'pushEntry',\n          paramName: 'entry.requestData'\n        });\n      } // Don't specify an ID since one is automatically generated.\n\n\n      delete entry.id;\n      entry.queueName = this._queueName;\n      await this._db.add(OBJECT_STORE_NAME, entry);\n    }\n    /**\n     * Preppend an entry first in the queue.\n     *\n     * @param {Object} entry\n     * @param {Object} entry.requestData\n     * @param {number} [entry.timestamp]\n     * @param {Object} [entry.metadata]\n     */\n\n\n    async unshiftEntry(entry) {\n      {\n        assert_mjs.assert.isType(entry, 'object', {\n          moduleName: 'workbox-background-sync',\n          className: 'QueueStore',\n          funcName: 'unshiftEntry',\n          paramName: 'entry'\n        });\n        assert_mjs.assert.isType(entry.requestData, 'object', {\n          moduleName: 'workbox-background-sync',\n          className: 'QueueStore',\n          funcName: 'unshiftEntry',\n          paramName: 'entry.requestData'\n        });\n      }\n\n      const firstEntry = await this._db.get(OBJECT_STORE_NAME);\n\n      if (firstEntry) {\n        // Pick an ID one less than the lowest ID in the object store.\n        entry.id = firstEntry.id - 1;\n      } else {\n        delete entry.id;\n      }\n\n      entry.queueName = this._queueName;\n      await this._db.add(OBJECT_STORE_NAME, entry);\n    }\n    /**\n     * Removes and returns the last entry in the queue matching the `queueName`.\n     *\n     * @return {Promise<Object>}\n     */\n\n\n    async popEntry() {\n      return this._removeEntry({\n        direction: 'prev'\n      });\n    }\n    /**\n     * Removes and returns the first entry in the queue matching the `queueName`.\n     *\n     * @return {Promise<Object>}\n     */\n\n\n    async shiftEntry() {\n      return this._removeEntry({\n        direction: 'next'\n      });\n    }\n    /**\n     * Removes and returns the first or last entry in the queue (based on the\n     * `direction` argument) matching the `queueName`.\n     *\n     * @return {Promise<Object>}\n     */\n\n\n    async _removeEntry({\n      direction\n    }) {\n      const [entry] = await this._db.getAllMatching(OBJECT_STORE_NAME, {\n        direction,\n        index: INDEXED_PROP,\n        query: IDBKeyRange.only(this._queueName),\n        count: 1\n      });\n\n      if (entry) {\n        await this._db.delete(OBJECT_STORE_NAME, entry.id); // Dont' expose the ID or queueName;\n\n        delete entry.id;\n        delete entry.queueName;\n        return entry;\n      }\n    }\n    /**\n     * Upgrades the database given an `upgradeneeded` event.\n     *\n     * @param {Event} event\n     */\n\n\n    _upgradeDb(event) {\n      const db = event.target.result;\n      const txn = event.target.transaction;\n      let oldEntries = [];\n      migrateDb_mjs.migrateDb(event, {\n        v1: next => {\n          // When migrating from version 0, this will not exist.\n          if (db.objectStoreNames.contains(OBJECT_STORE_NAME)) {\n            // Get any existing entries in the v1 requests store\n            // and then delete it.\n            const objStore = txn.objectStore(OBJECT_STORE_NAME);\n\n            objStore.openCursor().onsuccess = ({\n              target\n            }) => {\n              const cursor = target.result;\n\n              if (cursor) {\n                oldEntries.push(cursor.value);\n                cursor.continue();\n              } else {\n                db.deleteObjectStore(OBJECT_STORE_NAME);\n                next();\n              }\n            };\n          } else {\n            next();\n          }\n        },\n        v2: next => {\n          // Creates v2 of the requests store and adds back any existing\n          // entries in the new format.\n          const objStore = db.createObjectStore(OBJECT_STORE_NAME, {\n            autoIncrement: true,\n            keyPath: 'id'\n          });\n          objStore.createIndex(INDEXED_PROP, INDEXED_PROP, {\n            unique: false\n          });\n\n          if (oldEntries.length) {\n            for (const _ref of oldEntries) {\n              const {\n                queueName,\n                storableRequest\n              } = _ref;\n              // Move the timestamp from `storableRequest` to the top level.\n              const timestamp = storableRequest.timestamp; // Reformat the storable request data\n\n              const requestData = Object.assign(storableRequest.requestInit, {\n                url: storableRequest.url\n              });\n              objStore.add({\n                queueName,\n                timestamp,\n                requestData\n              });\n            }\n          }\n\n          next();\n        }\n      });\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  const serializableProperties = ['method', 'referrer', 'referrerPolicy', 'mode', 'credentials', 'cache', 'redirect', 'integrity', 'keepalive'];\n  /**\n   * A class to make it easier to serialize and de-serialize requests so they\n   * can be stored in IndexedDB.\n   *\n   * @private\n   */\n\n  class StorableRequest {\n    /**\n     * Converts a Request object to a plain object that can be structured\n     * cloned or JSON-stringified.\n     *\n     * @param {Request} request\n     * @return {Promise<StorableRequest>}\n     *\n     * @private\n     */\n    static async fromRequest(request) {\n      const requestData = {\n        url: request.url,\n        headers: {}\n      }; // Set the body if present.\n\n      if (request.method !== 'GET') {\n        // Use blob to support non-text request bodies,\n        // and clone first in case the caller still needs the request.\n        requestData.body = await request.clone().blob();\n      } // Convert the headers from an iterable to an object.\n\n\n      for (const [key, value] of request.headers.entries()) {\n        requestData.headers[key] = value;\n      } // Add all other serializable request properties\n\n\n      for (const prop of serializableProperties) {\n        if (request[prop] !== undefined) {\n          requestData[prop] = request[prop];\n        }\n      }\n\n      return new StorableRequest(requestData);\n    }\n    /**\n     * Accepts an object of request data that can be used to construct a\n     * `Request` but can also be stored in IndexedDB.\n     *\n     * @param {Object} requestData An object of request data that includes the\n     *     `url` plus any relevant properties of\n     *     [requestInit]{@link https://fetch.spec.whatwg.org/#requestinit}.\n     * @private\n     */\n\n\n    constructor(requestData) {\n      {\n        assert_mjs.assert.isType(requestData, 'object', {\n          moduleName: 'workbox-background-sync',\n          className: 'StorableRequest',\n          funcName: 'constructor',\n          paramName: 'requestData'\n        });\n        assert_mjs.assert.isType(requestData.url, 'string', {\n          moduleName: 'workbox-background-sync',\n          className: 'StorableRequest',\n          funcName: 'constructor',\n          paramName: 'requestData.url'\n        });\n      }\n\n      this._requestData = requestData;\n    }\n    /**\n     * Returns a deep clone of the instances `_requestData` object.\n     *\n     * @return {Object}\n     *\n     * @private\n     */\n\n\n    toObject() {\n      const requestData = Object.assign({}, this._requestData);\n      requestData.headers = Object.assign({}, this._requestData.headers);\n\n      if (requestData.body) {\n        requestData.body = requestData.body.slice();\n      }\n\n      return requestData;\n    }\n    /**\n     * Converts this instance to a Request.\n     *\n     * @return {Request}\n     *\n     * @private\n     */\n\n\n    toRequest() {\n      return new Request(this._requestData.url, this._requestData);\n    }\n    /**\n     * Creates and returns a deep clone of the instance.\n     *\n     * @return {StorableRequest}\n     *\n     * @private\n     */\n\n\n    clone() {\n      return new StorableRequest(this.toObject());\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  const queueNames = new Set();\n  /**\n   * A class to manage storing failed requests in IndexedDB and retrying them\n   * later. All parts of the storing and replaying process are observable via\n   * callbacks.\n   *\n   * @memberof workbox.backgroundSync\n   */\n\n  class Queue {\n    /**\n     * Creates an instance of Queue with the given options\n     *\n     * @param {string} name The unique name for this queue. This name must be\n     *     unique as it's used to register sync events and store requests\n     *     in IndexedDB specific to this instance. An error will be thrown if\n     *     a duplicate name is detected.\n     * @param {Object} [options]\n     * @param {Function} [options.onSync] A function that gets invoked whenever\n     *     the 'sync' event fires. The function is invoked with an object\n     *     containing the `queue` property (referencing this instance), and you\n     *     can use the callback to customize the replay behavior of the queue.\n     *.    When not set the `replayRequests()` method is called.\n     * @param {number} [options.maxRetentionTime=7 days] The amount of time (in\n     *     minutes) a request may be retried. After this amount of time has\n     *     passed, the request will be deleted from the queue.\n     */\n    constructor(name, {\n      onSync,\n      maxRetentionTime\n    } = {}) {\n      // Ensure the store name is not already being used\n      if (queueNames.has(name)) {\n        throw new WorkboxError_mjs.WorkboxError('duplicate-queue-name', {\n          name\n        });\n      } else {\n        queueNames.add(name);\n      }\n\n      this._name = name;\n      this._onSync = onSync || this.replayRequests;\n      this._maxRetentionTime = maxRetentionTime || MAX_RETENTION_TIME;\n      this._queueStore = new QueueStore(this._name);\n\n      this._addSyncListener();\n    }\n    /**\n     * @return {string}\n     */\n\n\n    get name() {\n      return this._name;\n    }\n    /**\n     * Stores the passed request in IndexedDB (with its timestamp and any\n     * metadata) at the end of the queue.\n     *\n     * @param {Object} entry\n     * @param {Request} entry.request The request to store in the queue.\n     * @param {Object} [entry.metadata] Any metadata you want associated with the\n     *     stored request. When requests are replayed you'll have access to this\n     *     metadata object in case you need to modify the request beforehand.\n     * @param {number} [entry.timestamp] The timestamp (Epoch time in\n     *     milliseconds) when the request was first added to the queue. This is\n     *     used along with `maxRetentionTime` to remove outdated requests. In\n     *     general you don't need to set this value, as it's automatically set\n     *     for you (defaulting to `Date.now()`), but you can update it if you\n     *     don't want particular requests to expire.\n     */\n\n\n    async pushRequest(entry) {\n      {\n        assert_mjs.assert.isType(entry, 'object', {\n          moduleName: 'workbox-background-sync',\n          className: 'Queue',\n          funcName: 'pushRequest',\n          paramName: 'entry'\n        });\n        assert_mjs.assert.isInstance(entry.request, Request, {\n          moduleName: 'workbox-background-sync',\n          className: 'Queue',\n          funcName: 'pushRequest',\n          paramName: 'entry.request'\n        });\n      }\n\n      await this._addRequest(entry, 'push');\n    }\n    /**\n     * Stores the passed request in IndexedDB (with its timestamp and any\n     * metadata) at the beginning of the queue.\n     *\n     * @param {Object} entry\n     * @param {Request} entry.request The request to store in the queue.\n     * @param {Object} [entry.metadata] Any metadata you want associated with the\n     *     stored request. When requests are replayed you'll have access to this\n     *     metadata object in case you need to modify the request beforehand.\n     * @param {number} [entry.timestamp] The timestamp (Epoch time in\n     *     milliseconds) when the request was first added to the queue. This is\n     *     used along with `maxRetentionTime` to remove outdated requests. In\n     *     general you don't need to set this value, as it's automatically set\n     *     for you (defaulting to `Date.now()`), but you can update it if you\n     *     don't want particular requests to expire.\n     */\n\n\n    async unshiftRequest(entry) {\n      {\n        assert_mjs.assert.isType(entry, 'object', {\n          moduleName: 'workbox-background-sync',\n          className: 'Queue',\n          funcName: 'unshiftRequest',\n          paramName: 'entry'\n        });\n        assert_mjs.assert.isInstance(entry.request, Request, {\n          moduleName: 'workbox-background-sync',\n          className: 'Queue',\n          funcName: 'unshiftRequest',\n          paramName: 'entry.request'\n        });\n      }\n\n      await this._addRequest(entry, 'unshift');\n    }\n    /**\n     * Removes and returns the last request in the queue (along with its\n     * timestamp and any metadata). The returned object takes the form:\n     * `{request, timestamp, metadata}`.\n     *\n     * @return {Promise<Object>}\n     */\n\n\n    async popRequest() {\n      return this._removeRequest('pop');\n    }\n    /**\n     * Removes and returns the first request in the queue (along with its\n     * timestamp and any metadata). The returned object takes the form:\n     * `{request, timestamp, metadata}`.\n     *\n     * @return {Promise<Object>}\n     */\n\n\n    async shiftRequest() {\n      return this._removeRequest('shift');\n    }\n    /**\n     * Adds the entry to the QueueStore and registers for a sync event.\n     *\n     * @param {Object} entry\n     * @param {Request} entry.request\n     * @param {Object} [entry.metadata]\n     * @param {number} [entry.timestamp=Date.now()]\n     * @param {string} operation ('push' or 'unshift')\n     */\n\n\n    async _addRequest({\n      request,\n      metadata,\n      timestamp = Date.now()\n    }, operation) {\n      const storableRequest = await StorableRequest.fromRequest(request.clone());\n      const entry = {\n        requestData: storableRequest.toObject(),\n        timestamp\n      }; // Only include metadata if it's present.\n\n      if (metadata) {\n        entry.metadata = metadata;\n      }\n\n      await this._queueStore[`${operation}Entry`](entry);\n      await this.registerSync();\n\n      {\n        logger_mjs.logger.log(`Request for '${getFriendlyURL_mjs.getFriendlyURL(storableRequest.url)}' has ` + `been added to background sync queue '${this._name}'.`);\n      }\n    }\n    /**\n     * Removes and returns the first or last (depending on `operation`) entry\n     * form the QueueStore that's not older than the `maxRetentionTime`.\n     *\n     * @param {string} operation ('pop' or 'shift')\n     * @return {Object|undefined}\n     */\n\n\n    async _removeRequest(operation) {\n      const now = Date.now();\n      const entry = await this._queueStore[`${operation}Entry`]();\n\n      if (entry) {\n        // Ignore requests older than maxRetentionTime. Call this function\n        // recursively until an unexpired request is found.\n        const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n\n        if (now - entry.timestamp > maxRetentionTimeInMs) {\n          return this._removeRequest(operation);\n        }\n\n        entry.request = new StorableRequest(entry.requestData).toRequest();\n        delete entry.requestData;\n        return entry;\n      }\n    }\n    /**\n     * Loops through each request in the queue and attempts to re-fetch it.\n     * If any request fails to re-fetch, it's put back in the same position in\n     * the queue (which registers a retry for the next sync event).\n     */\n\n\n    async replayRequests() {\n      let entry;\n\n      while (entry = await this.shiftRequest()) {\n        try {\n          await fetch(entry.request);\n\n          {\n            logger_mjs.logger.log(`Request for '${getFriendlyURL_mjs.getFriendlyURL(entry.request.url)}'` + `has been replayed in queue '${this._name}'`);\n          }\n        } catch (error) {\n          await this.unshiftRequest(entry);\n\n          {\n            logger_mjs.logger.log(`Request for '${getFriendlyURL_mjs.getFriendlyURL(entry.request.url)}'` + `failed to replay, putting it back in queue '${this._name}'`);\n          }\n\n          throw new WorkboxError_mjs.WorkboxError('queue-replay-failed', {\n            name: this._name\n          });\n        }\n      }\n\n      {\n        logger_mjs.logger.log(`All requests in queue '${this.name}' have successfully ` + `replayed; the queue is now empty!`);\n      }\n    }\n    /**\n     * Registers a sync event with a tag unique to this instance.\n     */\n\n\n    async registerSync() {\n      if ('sync' in registration) {\n        try {\n          await registration.sync.register(`${TAG_PREFIX}:${this._name}`);\n        } catch (err) {\n          // This means the registration failed for some reason, possibly due to\n          // the user disabling it.\n          {\n            logger_mjs.logger.warn(`Unable to register sync event for '${this._name}'.`, err);\n          }\n        }\n      }\n    }\n    /**\n     * In sync-supporting browsers, this adds a listener for the sync event.\n     * In non-sync-supporting browsers, this will retry the queue on service\n     * worker startup.\n     *\n     * @private\n     */\n\n\n    _addSyncListener() {\n      if ('sync' in registration) {\n        self.addEventListener('sync', event => {\n          if (event.tag === `${TAG_PREFIX}:${this._name}`) {\n            {\n              logger_mjs.logger.log(`Background sync for tag '${event.tag}'` + `has been received`);\n            }\n\n            event.waitUntil(this._onSync({\n              queue: this\n            }));\n          }\n        });\n      } else {\n        {\n          logger_mjs.logger.log(`Background sync replaying without background sync event`);\n        } // If the browser doesn't support background sync, retry\n        // every time the service worker starts up as a fallback.\n\n\n        this._onSync({\n          queue: this\n        });\n      }\n    }\n    /**\n     * Returns the set of queue names. This is primarily used to reset the list\n     * of queue names in tests.\n     *\n     * @return {Set}\n     *\n     * @private\n     */\n\n\n    static get _queueNames() {\n      return queueNames;\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * A class implementing the `fetchDidFail` lifecycle callback. This makes it\n   * easier to add failed requests to a background sync Queue.\n   *\n   * @memberof workbox.backgroundSync\n   */\n\n  class Plugin {\n    /**\n     * @param {...*} queueArgs Args to forward to the composed Queue instance.\n     *    See the [Queue]{@link workbox.backgroundSync.Queue} documentation for\n     *    parameter details.\n     */\n    constructor(...queueArgs) {\n      this._queue = new Queue(...queueArgs);\n      this.fetchDidFail = this.fetchDidFail.bind(this);\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @private\n     */\n\n\n    async fetchDidFail({\n      request\n    }) {\n      await this._queue.pushRequest({\n        request\n      });\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  var publicAPI = /*#__PURE__*/Object.freeze({\n    Queue: Queue,\n    Plugin: Plugin\n  });\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  return publicAPI;\n\n}(workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private));\n"],"file":"workbox-background-sync.dev.js"}